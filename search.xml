<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Valid Parenthesis</title>
      <link href="2021/02/18/ValidParenthesis/"/>
      <url>2021/02/18/ValidParenthesis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="括号的有效性（Valid-Parenthesis）"><a href="#括号的有效性（Valid-Parenthesis）" class="headerlink" title="括号的有效性（Valid Parenthesis）"></a>括号的有效性（Valid Parenthesis）</h1><blockquote><p>使用【栈】这一数据结构解决</p></blockquote><h3 id="一、思想"><a href="#一、思想" class="headerlink" title="一、思想"></a>一、思想</h3><p>  便利给定的字符串s,遇到一个左括号时，期望后续的遍历中有一个相同类型的右括号将其闭合。为满足后遇到的左括号要先闭合，我们最新遇到的左括号放入栈顶。遇到相同类型的右括号时将其从栈顶移出。<br>为了快速判断括号的类型，我们用哈希表存储每一种括号，键为右括号，值为相同类型的右括号。</p><blockquote><p>字符串的长度必须为偶数才满足一对一配对</p></blockquote><h3 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h3><ul><li><p><strong>python3</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">def isValid(self, s: str) -&gt; bool:</span><br><span class="line">#判断字符串的长度是否为偶数</span><br><span class="line">if len(s) % 2 &#x3D;&#x3D; 1: </span><br><span class="line">return False</span><br><span class="line">#创建一个哈希表进行存储   字典</span><br><span class="line">pairs &#x3D; &#123;</span><br><span class="line">&quot;)&quot;:&quot;(&quot;,</span><br><span class="line">&quot;&#125;&quot;:&quot;&#123;&quot;,</span><br><span class="line">&quot;]&quot;:&quot;[&quot;,</span><br><span class="line">&#125;</span><br><span class="line">#创建一个列表实现栈的功能</span><br><span class="line">stack &#x3D; list()</span><br><span class="line">#循环字符串中的每个字符</span><br><span class="line">for ch in s:</span><br><span class="line">#判断是否为列表stack中的键，如果不是则为左括号，存入栈顶</span><br><span class="line">if ch in pairs:</span><br><span class="line">#判断stack是否为空or || 判断stack列表的最后一个元素是否为对应的键值</span><br><span class="line">#if not stack 表示为空的话该语句为true</span><br><span class="line">if not stack or stack[-1] !&#x3D; pairs[ch]:</span><br><span class="line">return  False</span><br><span class="line">stack.pop()</span><br><span class="line">else:</span><br><span class="line">stack.append(ch)</span><br><span class="line">#返回判断stack是否为空的结果，如果not stack为true 表明stack已空，匹配完成</span><br><span class="line">return not stack</span><br><span class="line"></span><br><span class="line">   print(Solution.isValid( &#39;&#39;,&quot;[][[][]&quot;))</span><br><span class="line">   &gt;&gt;False</span><br></pre></td></tr></table></figure></li><li><p><strong>JavaScript</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h4&gt;括号的有效性&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;input&quot;&gt;</span><br><span class="line">    &lt;button onclick&#x3D;func1()&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;p class&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function func1() &#123;</span><br><span class="line">            let s &#x3D; document.getElementById(&#39;input&#39;)</span><br><span class="line">            &#x2F;&#x2F; console.log(s.value)</span><br><span class="line">            let result &#x3D; isValid(s.value)</span><br><span class="line">            &#x2F;&#x2F; console.log(typeof result)</span><br><span class="line">            &#x2F;&#x2F;--------</span><br><span class="line">            &#x2F;&#x2F; var wri &#x3D; document.getElementsById(&#39;demo12&#39;)</span><br><span class="line">            &#x2F;&#x2F; wri.innerHTML &#x3D; result</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; document.getElementsByClassName(&#39;p.demo&#39;).innerHTML &#x3D; result</span><br><span class="line">            &#x2F;&#x2F;------以上方法是不行的，以下是行的</span><br><span class="line">            &#x2F;&#x2F; console.log(wri)</span><br><span class="line">            &#x2F;&#x2F; 以下是方法二</span><br><span class="line">            wri &#x3D; document.querySelector(&#39;.demo&#39;)</span><br><span class="line">            wri.innerHTML &#x3D; result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var isValid &#x3D; function (s) &#123;</span><br><span class="line">            const n &#x3D; s.length</span><br><span class="line">            if (n % 2 &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">&#x2F;&#x2F;Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</span><br><span class="line">            const pairs &#x3D; new Map([</span><br><span class="line">                [&#39;)&#39;, &#39;(&#39;],</span><br><span class="line">                [&#39;]&#39;, &#39;[&#39;],</span><br><span class="line">                [&#39;&#125;&#39;, &#39;&#123;&#39;]</span><br><span class="line">            ])</span><br><span class="line">            const stk &#x3D; []</span><br><span class="line">            s.split(&#39;&#39;).forEach(ch &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;Map.prototype.has(key)返回一个布尔值，表示Map实例是否包含键对应的值。</span><br><span class="line">                if (pairs.has(ch)) &#123;</span><br><span class="line">&#x2F;&#x2F;Map.prototype.get(key)返回键对应的值，如果不存在，则返回undefined。</span><br><span class="line">                    if (!stk.length || stk[stk.length - 1] !&#x3D;&#x3D; pairs.get(ch)) &#123;</span><br><span class="line">                        return false</span><br><span class="line">                    &#125;</span><br><span class="line">                    stk.pop()</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stk.push(ch)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            return !stk.length</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>c++</strong><br>这里使用unodered_map容器：unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。<br>值得一提的是，unordered_map 容器在<unordered_map>头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句：</p><blockquote><p>#include &lt;unordered_map&gt;<br>using namespace std;<br>非完整代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">bool isValid(string s)&#123;</span><br><span class="line">int n&#x3D;s.size();</span><br><span class="line">if (n%2&#x3D;&#x3D;1)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unodered_map&lt;char,char&gt; pairs &#x3D;&#123;</span><br><span class="line">[&#39;)&#39;,&#39;()&#39;],</span><br><span class="line">[&#39;]&#39;,&#39;[]&#39;],</span><br><span class="line">[&#39;&#125;&#39;.&#39;&#123;&#125;]</span><br><span class="line">&#125;;</span><br><span class="line">stack&lt;cahr&gt; stk;</span><br><span class="line">for (char ch:s)&#123;</span><br><span class="line">if(stk.count(ch)||stk.top()!&#x3D;pairs[ch])&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">stk.pop();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">stk.push(ch);</span><br><span class="line">&#125;</span><br><span class="line">return stk.empty()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h3></li><li><p>时间复杂度：O(n)，其中 n是字符串 s 的长度。</p></li><li><p>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集。栈中的字符数量为 O(n)O(n)，而哈希表使用的空间为O(∣Σ∣)，相加即可得到总空间复杂度。</p></li></ul><blockquote><p>ALL FROM <a href="https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/">LeetCode</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> c++ </tag>
            
            <tag> Valid Parenthesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java素数</title>
      <link href="2021/01/20/Java%E7%B4%A0%E6%95%B0/"/>
      <url>2021/01/20/Java%E7%B4%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Part2-素数判断"><a href="#Part2-素数判断" class="headerlink" title="Part2 素数判断"></a>Part2 素数判断</h2><h3 id="分析一波"><a href="#分析一波" class="headerlink" title="分析一波"></a>分析一波</h3><blockquote><p>素数：质数，只能被1和自身整除的数字</p></blockquote><ol><li>判断是否是质数，只用判断除1和本身之外是否还有其他因子，如果有则不是质数</li><li>通过简单的数学知识我们可以知道，只需要判断到根号即可，也就是说我们减少了一半的工作</li><li>利用for循环和flag来进行逐一判断</li></ol><h3 id="java的输入代码"><a href="#java的输入代码" class="headerlink" title="java的输入代码"></a>java的输入代码</h3><ul><li>有一个Scanner类对象来监控键盘的录入情况</li><li>Scanner附属于标准输入流System.in </li><li>常用的next方法：</li><li>nextInt()：输入整数</li><li>nextDouble()：输入双精度数</li><li>nextFloat()：输入浮点数</li><li>nextLine()：输入字符串,可以接受空格或者tab，以enter结束</li><li>next()输入字符串，以空格或tab结束</li></ul><ul><li>定义一个对象s<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scanner s &#x3D; new Scanner(System.in)</span><br></pre></td></tr></table></figure></li><li>定义相应变量接受输入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String name &#x3D; s.nextLine();</span><br><span class="line">int age &#x3D; s.nextInt();</span><br><span class="line">double weight &#x3D; s.nextDouble();</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *for循环找出1000以内的所有素数,每八个一行</span><br><span class="line"> *素数：质数，只能被1和自身整除的数字</span><br><span class="line"> *求余数x%i</span><br><span class="line"> *j&lt;i  or j&lt;&#x3D;sqrt(i)</span><br><span class="line"> *&#x2F;</span><br><span class="line">package IsPrime;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class IsPrime &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; 开始</span><br><span class="line">int flag &#x3D; 0; &#x2F;&#x2F; 计数器，从0开始计数</span><br><span class="line">for (int i &#x3D; 2; i &lt; 1000; i++) &#123;</span><br><span class="line">boolean isPrime &#x3D; true; &#x2F;&#x2F; 标记符，判断i是否为素数</span><br><span class="line">&#x2F;&#x2F; 使用sqrt(i)时一定要等号，例如数字4</span><br><span class="line">for (int j &#x3D; 2; j &lt;&#x3D; Math.sqrt(i); j++) &#123; &#x2F;&#x2F; or j&lt;i</span><br><span class="line">if (i % j &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 没有余数说明不是素数</span><br><span class="line">isPrime &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 判断一行有多少个数</span><br><span class="line">if (isPrime) &#123;</span><br><span class="line">flag++;</span><br><span class="line">System.out.print(&quot; &quot; + i); &#x2F;&#x2F; 以空格分开数字</span><br><span class="line">if (flag % 8 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 因为从零开始计数，且前面先加了1</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 结束</span><br><span class="line">&#x2F;&#x2F; 判断输入的数字</span><br><span class="line">try (Scanner scanner &#x3D; new Scanner(System.in)) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个数字：&quot;);</span><br><span class="line">Integer num &#x3D; scanner.nextInt();</span><br><span class="line">boolean shi &#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 根号需要等号</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; Math.sqrt(num); i++) &#123;</span><br><span class="line">if (num % i &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 没有余数说明不是素数</span><br><span class="line">shi &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(shi ? num + &quot;是素数&quot; : num + &quot;不是素数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; over</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 方法体结束</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类结束</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="2021/01/20/Java%E5%9F%BA%E7%A1%80/"/>
      <url>2021/01/20/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Part1-基础"><a href="#Part1-基础" class="headerlink" title="Part1 基础"></a>Part1 基础</h2><ul><li><p>Java的加载与运行</p></li><li><p>*.java ：一个程序的源文件</p></li><li><p>javac.exe： 进行编译操作，会生成class文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DOS</span><br><span class="line">javac HelloWorld.java</span><br><span class="line">&#x2F;&#x2F;---&gt; 查看文件夹会发现多出来一个HelloWorld.class文件</span><br></pre></td></tr></table></figure></li><li><p>java ：运行class</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java HelloWorld</span><br><span class="line">&#x2F;&#x2F;注意此处只需要文件名不需要后缀</span><br></pre></td></tr></table></figure></li><li><p>Java的注释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#x2F;&#x2F; 单行注释</span><br><span class="line"></span><br><span class="line">- &#x2F;*</span><br><span class="line">    多行注释</span><br><span class="line">    多行注释</span><br><span class="line">  *&#x2F;</span><br><span class="line"></span><br><span class="line">- &#x2F;**</span><br><span class="line">  *  javadoc可提取的注释</span><br><span class="line">  *  javadoc.exe根据该注释生成帮助文档</span><br><span class="line">  *&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>public class 和 class的区别</p><ul><li>public class<br>公开的类，类名必须和源文件名保持一致</li><li>class<br>一个源文件中可定义多个class，javac编译之后会生成多个class文件</li></ul></li><li><p>HelloWorld</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个名为HelloWorld的公开的类</span><br><span class="line">&#x2F;&#x2F;类体中不能直接编写java语句【除声明变量之外】</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">&#x2F;*以下是一个程序的“主方法”，是程序的执行入口</span><br><span class="line">  static静态的</span><br><span class="line">  void空的</span><br><span class="line">  main 方法</span><br><span class="line">  (String[] args) 名为main的方法的形式参数列表&#x2F;&#x2F;(String[] adasdasd)</span><br><span class="line">*&#x2F;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">&#x2F;&#x2F;方法体</span><br><span class="line">&#x2F;&#x2F;Java的输出语句，加ln表示换行，不加不换行</span><br><span class="line">System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3></li><li><p>标识符<br>  可表示的元素：类名、方法名、变量名、接口名、常量名</p></li><li><p>标识符的命名规则  </p><ul><li>只能由“数字、字母、下划线_、美元符号$”组成    </li><li>不能以数字开头</li><li>严格区分大小写</li><li>关键字不能做标识符</li><li>理论上无长度限制</li></ul></li><li><p>命名规范</p><ul><li>见名知意</li><li>遵守驼峰命名方式</li><li>类名、接口名：首字母大写，后面每个单词的首字母大写</li><li>变量名、方法名：首字母小写，后面的每个单词的首字母大写</li><li>常量名：全部大写</li></ul></li></ul><h3 id="字面值（常量）"><a href="#字面值（常量）" class="headerlink" title="字面值（常量）"></a>字面值（常量）</h3><ul><li>Java中的所有的字符串型的字面值必须使用””括起来</li><li>字符型的字面值使用半角单引号’’</li><li>整数、浮点数</li><li>布尔值：true、false</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>变量的作用域：<br>出了大括号就不行了。即作用域为一个大括号内。</p></blockquote><ul><li>局部变量</li></ul><ul><li>在方法体当中声明的变量叫做局部变量</li></ul><ul><li>成员变量</li></ul><ul><li>在方法体外【类体之内】声明的变量叫做成员变量</li></ul><blockquote><p>在不同的作用域当中变量名可以重名<br>Java 遵循就近原则，即访问距离最近的变量</p></blockquote><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote><p>类似于c</p></blockquote><ul><li>类型转换<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long x&#x3D;46546;</span><br><span class="line">&#x2F;&#x2F;转换: </span><br><span class="line">y&#x3D;(int)x;</span><br><span class="line">&#x2F;&#x2F;有时会有精度损失</span><br></pre></td></tr></table></figure></li><li>关于byte类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte i &#x3D; 5 &#x2F;&#x2F;可以-128~127</span><br><span class="line">&#x2F;&#x2F;i &#x3D; 128  &#x2F;&#x2F;不可以</span><br><span class="line">i &#x3D; i + 5  &#x2F;&#x2F;不可以</span><br><span class="line">i &#x3D; (byte)(i+5) &#x2F;&#x2F; 可以</span><br><span class="line">i +&#x3D; 5     &#x2F;&#x2F;可以，等同于i &#x3D; (byte)(i+5)</span><br></pre></td></tr></table></figure></li><li>三元运算符  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">布尔表达式 ? (true)表达式1:(false)表达式2</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/07/hello-world/"/>
      <url>2021/01/07/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
