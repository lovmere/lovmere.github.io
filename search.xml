<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git</title>
      <link href="2021/04/21/Git/"/>
      <url>2021/04/21/Git/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><pre><code>Git常用命令</code></pre><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/iuning/myPictures/git-command.jpg" alt="关系图"></p><h4 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h4><ol><li><strong>git init newrepoName</strong>：初始化仓库。</li><li><strong>git clone</strong>：克隆下载一份远程仓库，也就是下载一个项目。</li></ol><h4 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h4><ol><li><p><strong>git add</strong>：添加文件到暂存区。</p></li><li><p><strong>git commit</strong>：将暂存区的内容添加到仓库。</p><ul><li><code>git commit -am &#39;修改内容&#39;</code></li></ul></li><li><p><strong>git status</strong>：查看仓库当前的状态，显示有变更的文件。</p></li><li><p><strong>git diff</strong>：比较文件的不同，及暂存区和工作区的差异。</p></li><li><p><strong>git reset</strong>：回退版本。</p><ul><li>当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li></ul></li><li><p><strong>git rm</strong>：删除工作区的文件。</p><ul><li>当执行 git rm –cached file 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li></ul></li><li><p><strong>git mv</strong>：移动或者重命名工作区文件。</p></li></ol><h4 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h4><ol><li><strong>git log</strong>：查看历史提交记录<ul><li>在使用Git提交了若干更新之后，又或者克隆了某个项目，想回顾一下提交历史，可以使用git log。</li><li><code>git log --oneline</code> 查看历史记录的简洁版本。</li><li>–graph ：查看历史中什么时候出现了分支合并。</li><li>–reverse：来逆向显示所有日志。</li><li><code>git log --author</code> ：如果只想查找指定用户的提交日志可以使用命令。</li><li>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</li></ul></li><li><strong>git blame file</strong>：以列表的形式查看指定文件的历史修改记录。</li></ol><h4 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h4><ol><li><strong>git remote</strong>：远程仓库操作。<ul><li><code>git remote add [shortname] [url]</code>  添加一个新的远程仓库，并指定一个简单的名字</li><li><code>git remote -v </code>可以查看每个别名的实际连接地址</li><li><code>git remote rm [shortname]  </code>删除仓库</li></ul></li></ol><ul><li><strong>git fetch</strong>：从远程获取代码库。<ul><li><code>git fetch [name]</code> 获取远程更新</li><li><code>git merge [name]</code>  从远端仓库提取数据并尝试合并到当前分支</li></ul></li></ul><ol start="2"><li><strong>git pull</strong>：下载远程代码并合并。</li><li><strong>git push</strong>：上传远程代码并合并。<ul><li><code>git push [alias] [branch]</code>   //将你的[branch]分支推送成为[alias]远程仓库上的[branch]分支。</li></ul></li></ol><h3 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h3><pre><code>使用分支意味着你可以从开发主线上分离开来，然后从不影响主线的同时继续工作。也就是创建分支将更改保存在分支上，在保持主线不变的情况下做更新操作，之后可以将其合并到主线。</code></pre><h4 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h4><ol><li><p>查看分支：<br> <code>git branch</code></p></li><li><p>创建分支命令：<br><code> git branch (branchname)</code></p></li><li><p>合并分支命令(合并分支到当前分支)：<br><code> git merge dev</code><br>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p></li></ol><p>如果要强制禁用Fast forward模式，Git就会-用-no-ff方式在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><blockquote><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p></blockquote><ol start="4"><li><p>合并冲突：主线和分支都有内容产生了改变，git无法执行快速合并。通过_git diff_查看两者的不同。需要手动的去修改，修改之后，可以用_git add_告诉Git文件冲突已经解决。</p></li><li><p>切换分支命令：</p><ul><li>checkout<blockquote><ul><li>当执行 <em>git checkout .</em> 或者 <em>git checkout – <file></em> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li><li>当执行 <em>git checkout HEAD .</em> 或者 <em>git checkout HEAD <file></em> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动</li></ul></blockquote></li><li><code> git checkout (branchname)</code></li><li>实际上，使用switch更科学：<code>git switch -c [newbranch]</code>、<code>git switch [existbranch]</code></li></ul></li><li><p>创建+切换分支：<br> <code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p></li></ol><ol start="7"><li>删除分支：<br><code> git branch -d (branchname)</code></li></ol><h4 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h4><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br><code>git checkout -b issue</code><br>当前工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；<br>有两个方式恢复：</p><ul><li><code>git stash apply</code>：恢复后stash内容并不删除，需要用<code>git stash drop</code>删除。</li><li><code>git stash pop</code>：恢复后删除stash内容。</li></ul><p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p><h4 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h4><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。<br>如果要丢弃一个没有被合并过的分支，可以通过*git branch -D <name>*强行删除。</p><h4 id="团队远程操作："><a href="#团队远程操作：" class="headerlink" title="团队远程操作："></a>团队远程操作：</h4><ol><li><p>查看远程库信息，使用git remote -v；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p></li><li><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p></li></ol><h4 id="rebese"><a href="#rebese" class="headerlink" title="rebese"></a>rebese</h4><p><code>git rebase</code>操作可以把本地未push的分叉(主要由于冲突产生)提交历史整理成直线；</p><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><blockquote><p>rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了</p></blockquote><h3 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h3><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag给它打上标签。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。相较于commit的复杂tag可以简单易记，像是ip地址和域名的关系？</p><ul><li><strong>git tag v1.1</strong>:创建一个简单的标签。</li><li><strong>git tag</strong>：查看已有标签</li><li><strong>-a</strong> 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。</li><li>当你执行 <em>git tag -a</em> 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</li><li>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</li><li>指定标签信息的命令：<br><code> git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;</code></li><li>PGP签名标签命令：<br><code> git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;</code></li><li>删除标签：<code>git tag -d v1.1</code></li><li>查看此版本所修改的内容：<code> git show v1.0</code></li></ul><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li><strong>Git简明指南</strong>：<a href="https://www.runoob.com/manual/git-guide/">https://www.runoob.com/manual/git-guide/</a></li><li>__Git菜鸟教程__：<a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></li><li><strong>Git廖雪峰教程</strong>：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></li><li><strong>Git完整手册地址</strong>:  <a href="http://git-scm.com/docs">http://git-scm.com/docs</a></li><li><strong>Git官网</strong>: <a href="https://git-scm.com/">https://git-scm.com/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valid Parenthesis</title>
      <link href="2021/02/18/ValidParenthesis/"/>
      <url>2021/02/18/ValidParenthesis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="括号的有效性（Valid-Parenthesis）"><a href="#括号的有效性（Valid-Parenthesis）" class="headerlink" title="括号的有效性（Valid Parenthesis）"></a>括号的有效性（Valid Parenthesis）</h1><blockquote><p>使用【栈】这一数据结构解决</p></blockquote><h3 id="一、思想"><a href="#一、思想" class="headerlink" title="一、思想"></a>一、思想</h3><p>  便利给定的字符串s,遇到一个左括号时，期望后续的遍历中有一个相同类型的右括号将其闭合。为满足后遇到的左括号要先闭合，我们最新遇到的左括号放入栈顶。遇到相同类型的右括号时将其从栈顶移出。<br>为了快速判断括号的类型，我们用哈希表存储每一种括号，键为右括号，值为相同类型的右括号。</p><blockquote><p>字符串的长度必须为偶数才满足一对一配对</p></blockquote><h3 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h3><ul><li><p><strong>python3</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">def isValid(self, s: str) -&gt; bool:</span><br><span class="line">#判断字符串的长度是否为偶数</span><br><span class="line">if len(s) % 2 &#x3D;&#x3D; 1: </span><br><span class="line">return False</span><br><span class="line">#创建一个哈希表进行存储   字典</span><br><span class="line">pairs &#x3D; &#123;</span><br><span class="line">&quot;)&quot;:&quot;(&quot;,</span><br><span class="line">&quot;&#125;&quot;:&quot;&#123;&quot;,</span><br><span class="line">&quot;]&quot;:&quot;[&quot;,</span><br><span class="line">&#125;</span><br><span class="line">#创建一个列表实现栈的功能</span><br><span class="line">stack &#x3D; list()</span><br><span class="line">#循环字符串中的每个字符</span><br><span class="line">for ch in s:</span><br><span class="line">#判断是否为列表stack中的键，如果不是则为左括号，存入栈顶</span><br><span class="line">if ch in pairs:</span><br><span class="line">#判断stack是否为空or || 判断stack列表的最后一个元素是否为对应的键值</span><br><span class="line">#if not stack 表示为空的话该语句为true</span><br><span class="line">if not stack or stack[-1] !&#x3D; pairs[ch]:</span><br><span class="line">return  False</span><br><span class="line">stack.pop()</span><br><span class="line">else:</span><br><span class="line">stack.append(ch)</span><br><span class="line">#返回判断stack是否为空的结果，如果not stack为true 表明stack已空，匹配完成</span><br><span class="line">return not stack</span><br><span class="line"></span><br><span class="line">   print(Solution.isValid( &#39;&#39;,&quot;[][[][]&quot;))</span><br><span class="line">   &gt;&gt;False</span><br></pre></td></tr></table></figure></li><li><p><strong>JavaScript</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h4&gt;括号的有效性&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;input&quot;&gt;</span><br><span class="line">    &lt;button onclick&#x3D;func1()&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;p class&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function func1() &#123;</span><br><span class="line">            let s &#x3D; document.getElementById(&#39;input&#39;)</span><br><span class="line">            &#x2F;&#x2F; console.log(s.value)</span><br><span class="line">            let result &#x3D; isValid(s.value)</span><br><span class="line">            &#x2F;&#x2F; console.log(typeof result)</span><br><span class="line">            &#x2F;&#x2F;--------</span><br><span class="line">            &#x2F;&#x2F; var wri &#x3D; document.getElementsById(&#39;demo12&#39;)</span><br><span class="line">            &#x2F;&#x2F; wri.innerHTML &#x3D; result</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; document.getElementsByClassName(&#39;p.demo&#39;).innerHTML &#x3D; result</span><br><span class="line">            &#x2F;&#x2F;------以上方法是不行的，以下是行的</span><br><span class="line">            &#x2F;&#x2F; console.log(wri)</span><br><span class="line">            &#x2F;&#x2F; 以下是方法二</span><br><span class="line">            wri &#x3D; document.querySelector(&#39;.demo&#39;)</span><br><span class="line">            wri.innerHTML &#x3D; result</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var isValid &#x3D; function (s) &#123;</span><br><span class="line">            const n &#x3D; s.length</span><br><span class="line">            if (n % 2 &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">&#x2F;&#x2F;Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。</span><br><span class="line">            const pairs &#x3D; new Map([</span><br><span class="line">                [&#39;)&#39;, &#39;(&#39;],</span><br><span class="line">                [&#39;]&#39;, &#39;[&#39;],</span><br><span class="line">                [&#39;&#125;&#39;, &#39;&#123;&#39;]</span><br><span class="line">            ])</span><br><span class="line">            const stk &#x3D; []</span><br><span class="line">            s.split(&#39;&#39;).forEach(ch &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;Map.prototype.has(key)返回一个布尔值，表示Map实例是否包含键对应的值。</span><br><span class="line">                if (pairs.has(ch)) &#123;</span><br><span class="line">&#x2F;&#x2F;Map.prototype.get(key)返回键对应的值，如果不存在，则返回undefined。</span><br><span class="line">                    if (!stk.length || stk[stk.length - 1] !&#x3D;&#x3D; pairs.get(ch)) &#123;</span><br><span class="line">                        return false</span><br><span class="line">                    &#125;</span><br><span class="line">                    stk.pop()</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stk.push(ch)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            return !stk.length</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>c++</strong><br>这里使用unodered_map容器：unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。<br>值得一提的是，unordered_map 容器在<unordered_map>头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句：</p><blockquote><p>#include &lt;unordered_map&gt;<br>using namespace std;<br>非完整代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">bool isValid(string s)&#123;</span><br><span class="line">int n&#x3D;s.size();</span><br><span class="line">if (n%2&#x3D;&#x3D;1)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unodered_map&lt;char,char&gt; pairs &#x3D;&#123;</span><br><span class="line">[&#39;)&#39;,&#39;(&#39;],</span><br><span class="line">[&#39;]&#39;,&#39;[&#39;],</span><br><span class="line">[&#39;&#125;&#39;.&#39;&#123;&#39;]</span><br><span class="line">&#125;;</span><br><span class="line">stack&lt;cahr&gt; stk;</span><br><span class="line">for (char ch:s)&#123;</span><br><span class="line">if(stk.count(ch)||stk.top()!&#x3D;pairs[ch])&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">stk.pop();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">stk.push(ch);</span><br><span class="line">&#125;</span><br><span class="line">return stk.empty()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、复杂度分析"><a href="#三、复杂度分析" class="headerlink" title="三、复杂度分析"></a>三、复杂度分析</h3></li><li><p>时间复杂度：O(n)，其中 n是字符串 s 的长度。</p></li><li><p>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集。栈中的字符数量为 O(n)O(n)，而哈希表使用的空间为O(∣Σ∣)，相加即可得到总空间复杂度。</p></li></ul><blockquote><p>ALL FROM <a href="https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/">LeetCode</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> c++ </tag>
            
            <tag> Valid Parenthesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础（二）</title>
      <link href="2021/01/20/Java%E7%B4%A0%E6%95%B0/"/>
      <url>2021/01/20/Java%E7%B4%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Part2-素数判断"><a href="#Part2-素数判断" class="headerlink" title="Part2 素数判断"></a>Part2 素数判断</h2><h3 id="分析一波"><a href="#分析一波" class="headerlink" title="分析一波"></a>分析一波</h3><blockquote><p>素数：质数，只能被1和自身整除的数字</p></blockquote><ol><li>判断是否是质数，只用判断除1和本身之外是否还有其他因子，如果有则不是质数</li><li>通过简单的数学知识我们可以知道，只需要判断到根号即可，也就是说我们减少了一半的工作</li><li>利用for循环和flag来进行逐一判断</li></ol><h3 id="java的输入代码"><a href="#java的输入代码" class="headerlink" title="java的输入代码"></a>java的输入代码</h3><ul><li>有一个Scanner类对象来监控键盘的录入情况</li><li>Scanner附属于标准输入流System.in </li><li>常用的next方法：</li><li>nextInt()：输入整数</li><li>nextDouble()：输入双精度数</li><li>nextFloat()：输入浮点数</li><li>nextLine()：输入字符串,可以接受空格或者tab，以enter结束</li><li>next()输入字符串，以空格或tab结束</li></ul><ul><li>定义一个对象s<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scanner s &#x3D; new Scanner(System.in)</span><br></pre></td></tr></table></figure></li><li>定义相应变量接受输入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String name &#x3D; s.nextLine();</span><br><span class="line">int age &#x3D; s.nextInt();</span><br><span class="line">double weight &#x3D; s.nextDouble();</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *for循环找出1000以内的所有素数,每八个一行</span><br><span class="line"> *素数：质数，只能被1和自身整除的数字</span><br><span class="line"> *求余数x%i</span><br><span class="line"> *j&lt;i  or j&lt;&#x3D;sqrt(i)</span><br><span class="line"> *&#x2F;</span><br><span class="line">package IsPrime;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class IsPrime &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F; 开始</span><br><span class="line">int flag &#x3D; 0; &#x2F;&#x2F; 计数器，从0开始计数</span><br><span class="line">for (int i &#x3D; 2; i &lt; 1000; i++) &#123;</span><br><span class="line">boolean isPrime &#x3D; true; &#x2F;&#x2F; 标记符，判断i是否为素数</span><br><span class="line">&#x2F;&#x2F; 使用sqrt(i)时一定要等号，例如数字4</span><br><span class="line">for (int j &#x3D; 2; j &lt;&#x3D; Math.sqrt(i); j++) &#123; &#x2F;&#x2F; or j&lt;i</span><br><span class="line">if (i % j &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 没有余数说明不是素数</span><br><span class="line">isPrime &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 判断一行有多少个数</span><br><span class="line">if (isPrime) &#123;</span><br><span class="line">flag++;</span><br><span class="line">System.out.print(&quot; &quot; + i); &#x2F;&#x2F; 以空格分开数字</span><br><span class="line">if (flag % 8 &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 因为从零开始计数，且前面先加了1</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 结束</span><br><span class="line">&#x2F;&#x2F; 判断输入的数字</span><br><span class="line">try (Scanner scanner &#x3D; new Scanner(System.in)) &#123;</span><br><span class="line">System.out.println(&quot;请输入一个数字：&quot;);</span><br><span class="line">Integer num &#x3D; scanner.nextInt();</span><br><span class="line">boolean shi &#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 根号需要等号</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; Math.sqrt(num); i++) &#123;</span><br><span class="line">if (num % i &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 没有余数说明不是素数</span><br><span class="line">shi &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(shi ? num + &quot;是素数&quot; : num + &quot;不是素数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; over</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 方法体结束</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类结束</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
            <tag> 素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础（一）</title>
      <link href="2021/01/20/Java%E5%9F%BA%E7%A1%80/"/>
      <url>2021/01/20/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Part1-基础"><a href="#Part1-基础" class="headerlink" title="Part1 基础"></a>Part1 基础</h2><ul><li><p>Java的加载与运行</p></li><li><p>*.java ：一个程序的源文件</p></li><li><p>javac.exe： 进行编译操作，会生成class文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DOS</span><br><span class="line">javac HelloWorld.java</span><br><span class="line">&#x2F;&#x2F;---&gt; 查看文件夹会发现多出来一个HelloWorld.class文件</span><br></pre></td></tr></table></figure></li><li><p>java ：运行class</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java HelloWorld</span><br><span class="line">&#x2F;&#x2F;注意此处只需要文件名不需要后缀</span><br></pre></td></tr></table></figure></li><li><p>Java的注释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &#x2F;&#x2F; 单行注释</span><br><span class="line"></span><br><span class="line">- &#x2F;*</span><br><span class="line">    多行注释</span><br><span class="line">    多行注释</span><br><span class="line">  *&#x2F;</span><br><span class="line"></span><br><span class="line">- &#x2F;**</span><br><span class="line">  *  javadoc可提取的注释</span><br><span class="line">  *  javadoc.exe根据该注释生成帮助文档</span><br><span class="line">  *&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>public class 和 class的区别</p><ul><li>public class<br>公开的类，类名必须和源文件名保持一致</li><li>class<br>一个源文件中可定义多个class，javac编译之后会生成多个class文件</li></ul></li><li><p>HelloWorld</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个名为HelloWorld的公开的类</span><br><span class="line">&#x2F;&#x2F;类体中不能直接编写java语句【除声明变量之外】</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">&#x2F;*以下是一个程序的“主方法”，是程序的执行入口</span><br><span class="line">  static静态的</span><br><span class="line">  void空的</span><br><span class="line">  main 方法</span><br><span class="line">  (String[] args) 名为main的方法的形式参数列表&#x2F;&#x2F;(String[] adasdasd)</span><br><span class="line">*&#x2F;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">&#x2F;&#x2F;方法体</span><br><span class="line">&#x2F;&#x2F;Java的输出语句，加ln表示换行，不加不换行</span><br><span class="line">System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3></li><li><p>标识符<br>  可表示的元素：类名、方法名、变量名、接口名、常量名</p></li><li><p>标识符的命名规则  </p><ul><li>只能由“数字、字母、下划线_、美元符号$”组成    </li><li>不能以数字开头</li><li>严格区分大小写</li><li>关键字不能做标识符</li><li>理论上无长度限制</li></ul></li><li><p>命名规范</p><ul><li>见名知意</li><li>遵守驼峰命名方式</li><li>类名、接口名：首字母大写，后面每个单词的首字母大写</li><li>变量名、方法名：首字母小写，后面的每个单词的首字母大写</li><li>常量名：全部大写</li></ul></li></ul><h3 id="字面值（常量）"><a href="#字面值（常量）" class="headerlink" title="字面值（常量）"></a>字面值（常量）</h3><ul><li>Java中的所有的字符串型的字面值必须使用””括起来</li><li>字符型的字面值使用半角单引号’’</li><li>整数、浮点数</li><li>布尔值：true、false</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>变量的作用域：<br>出了大括号就不行了。即作用域为一个大括号内。</p></blockquote><ul><li>局部变量</li></ul><ul><li>在方法体当中声明的变量叫做局部变量</li></ul><ul><li>成员变量</li></ul><ul><li>在方法体外【类体之内】声明的变量叫做成员变量</li></ul><blockquote><p>在不同的作用域当中变量名可以重名<br>Java 遵循就近原则，即访问距离最近的变量</p></blockquote><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote><p>类似于c</p></blockquote><ul><li>类型转换<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long x&#x3D;46546;</span><br><span class="line">&#x2F;&#x2F;转换: </span><br><span class="line">y&#x3D;(int)x;</span><br><span class="line">&#x2F;&#x2F;有时会有精度损失</span><br></pre></td></tr></table></figure></li><li>关于byte类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte i &#x3D; 5 &#x2F;&#x2F;可以-128~127</span><br><span class="line">&#x2F;&#x2F;i &#x3D; 128  &#x2F;&#x2F;不可以</span><br><span class="line">i &#x3D; i + 5  &#x2F;&#x2F;不可以</span><br><span class="line">i &#x3D; (byte)(i+5) &#x2F;&#x2F; 可以</span><br><span class="line">i +&#x3D; 5     &#x2F;&#x2F;可以，等同于i &#x3D; (byte)(i+5)</span><br></pre></td></tr></table></figure></li><li>三元运算符  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">布尔表达式 ? (true)表达式1:(false)表达式2</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/07/hello-world/"/>
      <url>2021/01/07/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
